<!DOCTYPE html>
<html lang="en">

<head>
    <title>Water</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../assets/css/main.css" />
</head>

<body class="subpage">

    <!-- Header -->
    <header id="header">
        <div class="logo"><a href="../index.html">Project <span>by JAMES KARRAN</span></a></div>
        <a href="#menu">Menu</a>
    </header>

    <!-- Nav -->
    <nav id="menu">
        <ul class="links">
            <li><a href="../index.html">Home</a></li>
            <li><a href="elements_page.html">About The Project</a></li>
            <li><a href="terrain.html">Terrain</a></li>
            <li><a href="water.html">Water</a></li>
            <li><a href="grass.html">Grass</a></li>
            <li><a href="interactibles.html">Interactibles</a></li>
        </ul>
    </nav>

    <!-- One -->
    <section id="One" class="wrapper style3">
        <div class="inner">
            <header class="align-center">
                <p>Development Notes</p>
                <h2>Water</h2>
            </header>
        </div>
    </section>

    <!-- Two -->
    <section id="two" class="wrapper style">
        <div class="inner">
            <div class="box">
                <div class="content">
                    <p>
                        A Devblog wouldn't be complete without a post about water. There's a million different ways of
                        doing it and they could be vastly different depending on what you need. Elements has a flat
                        shaded
                        low poly style so you would think that low poly water would fit quite nicely but when we tried
                        it,
                        we weren't satisfied with the result. What we ended up with is probably the polar opposite of
                        low poly:
                        a Tessellation shader. To make the shader we used <a
                            href="https://catlikecoding.com/unity/tutorials/flow/waves/">Catlike Coding's excellent
                            tutorial</a>
                        on waves and adding the features we needed such as a foamline, noise and tessellation. It's
                        possible to create
                        good looking water using a simple flat plane but in Elements we have a whole section of the game
                        in a water zone so we wanted something a bit more unique.
                    </p>
                    <p>

                        On a high level having a Tessellation shader means that geometry is automatically generated by
                        the GPU at
                        runtime. This comes in very handy when doing vertex displacement like waves because you have
                        more vertices to work with.
                        This gif shows the difference between just using the mesh and having tessellation enabled:

                    </p>
                    <p>
                        Tessellation is pretty complex when doing it from scratch but we can use the power surface
                        shaders to just tell Unity
                        that we're gonna make use of it. Unity provides various methods but in our case we just want to
                        tassellate wathever portion of
                        the plane is close to the camera and leave everything else low poly. To do so, we just specify a
                        custom tessellation function
                        and then call one of Unity's helper functions
                        <pre>
                            <code>
#pragma surface surf Standard alpha vertex:vert tessellate:tessDistance

#pragma target 4.6
#include "Tessellation.cginc"

...

float4 tessDistance (appdata_full v0, appdata_full v1, appdata_full v2) {
    return UnityDistanceBasedTess(v0.vertex, v1.vertex, v2.vertex, _minDist, _maxDist, _Tess);
}
                            </code>
                        </pre>
                    </p>
                    <p>
                        This snippet allows us to tessellate just the area of the plane wich is within _maxDist and
                        linearly interpolate to 0
                        when further away.
                    </p>
                    <h3>
                        Waves
                    </h3>
                    <p>
                        There's various ways of doing waves, if you're looking for a simple solution you could just use
                        a sine wave.
                        For more realistic looking waves we used Gerstner waves. To understand how Gerstner waves work
                        and how the math
                        works check out <a href="https://catlikecoding.com/unity/tutorials/flow/waves/">Catlike Coding's
                            Tutorial</a>. For the
                        purposes of this post, we'll be using this function as a "black box", simply plugging values in
                        and getting our wave as a result.
                    </p>
                    <pre>
                        <code>
half3 GerstnerWave (half4 wave, half3 p, inout half3 tangent, inout half3 binormal, inout half4 randomFac) {
    float steepness = wave.z;
    float wavelength = wave.w;
    float k = 2 * UNITY_PI / wavelength;
    float c = sqrt(9.8 / k);
    half2 d = normalize(wave.xy);
    float f = k * (dot(d, p.xz) - c * _Time.y);
    float a = steepness / k;

    tangent += half3(
        -d.x * d.x * (steepness * sin(f)),
        d.x * (steepness * cos(f)),
        -d.x * d.y * (steepness * sin(f))
    );
    binormal += half3(
        -d.x * d.y * (steepness * sin(f)),
        d.y * (steepness * cos(f)),
        -d.y * d.y * (steepness * sin(f))
    );
    return float3(
        d.x * (a * cos(f)) + randomFac.r,
        a * sin(f) + randomFac.r,
        d.y * (a * cos(f)) + randomFac.r
    );
}
                    </code>
                </pre>

                    <p>
                        In our custom vertex function we use a Perlin noise texture to add some random movement to the
                        waves
                        making them look less perfectly regular and then we call our gerstnerWave function as many times
                        as we need.
                        In this case we'll stick to 3 (even though 2 is better for most cases).

                    </p>

                    <pre>
                    <code>
void vert(inout appdata_full vertexData) {
    half4 randomFac = tex2Dlod(_NoiseTex,half4((vertexData.texcoord.xy + (_Time.y * _NoiseSpeed)) * _NoiseContribution,0,0));
    half3 gridPoint = vertexData.vertex;
    half3 tangent = half3(1, 0, 0);
    half3 binormal = half3(0, 0, 1);
    half3 p = gridPoint;
    p += GerstnerWave(_WaveA, gridPoint, tangent, binormal, randomFac);
    p += GerstnerWave(_WaveB, gridPoint, tangent, binormal, randomFac);
    p += GerstnerWave(_WaveC, gridPoint, tangent, binormal, randomFac);
    half3 normal = normalize(cross(binormal, tangent));
    vertexData.vertex.xyz = p;
    _height=vertexData.vertex.y;
    vertexData.normal = normal;
}
                        </code>
                    </pre>
                    <p>
                        And this is the result:
                    </p>
                    <h3>
                        Foamline
                    </h3>
                    <p>
                        So we're done with the vertex function and if what you're looking for is just making an ocean, you could probably just stop here. But we
                        also wanted a foamline
                        when the water plane intersects another object. To do so, we need the camera's <a
                            href="https://docs.unity3d.com/Manual/SL-CameraDepthTexture.html">Depth Texture (click to
                            learn what it is)</a>
                        which can me automatically generated from Unity's default camera by just attaching this simple
                        script to the camera
                    </p>

                    <pre>
                        <code>
private Camera cam;

void Start() {
    cam = GetComponent<Camera>();
    cam.depthTextureMode = DepthTextureMode.DepthNormals;
}                           
                            </code>
                    </pre>
                    <p>
                        So now we have the depth texture but in order to make use of it we need to transform it to screen space
                        and attatch it in some way to an inspector parameter, this is how we did it:
                    </p>
                    <pre>
                        <code>
half depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(IN.screenPos));
depth = LinearEyeDepth(depth * _Threshold);
                        </code>
                    </pre>
                        <p>
                            Now on to the good stuff. We can now add a white foamline on every object intersecting the water plane by just using
                            the depth texture :
                        </p>
                        <pre>
                            <code>
half3 color = (saturate(1-((depth-IN.screenPos.w))) + _Color;
o.Albedo=color;
// Calculate linear falloff value
half falloff = 1.0 - ((depth-IN.screenPos.w) / _Threshold+0.4);
o.Albedo += saturate(falloff);
                            </code>
                        </pre>
                        <p>
                            So this is what we have so far:
                        </p>
                        <p>
                            This looks ok but there's no texture to it. We could use a standard texture and sample it but to make it feel 
                            more dynamic we decided to use a Voronoi pattern. As we did for the gerstnerWave we could in theory just use the
                            voronoi algorithm as a black box. This is what we used:
                        </p>
                        <pre>
                            <code>
half3 voronoiNoise(half3 value){
    half3 baseCell = floor(value);

    //first pass to find the closest cell
    half minDistToCell = 10;
    half3 toClosestCell;
    half3 closestCell;
    [unroll]
    for(int x1=-1; x1<=1; x1++){
        [unroll]
        for(int y1=-1; y1<=1; y1++){
            [unroll]
            for(int z1=-1; z1<=1; z1++){
                half3 cell = baseCell + half3(x1, y1, z1);
                half3 cellPosition = cell + rand3dTo3d(cell);
                half3 toCell = cellPosition - value;
                half distToCell = length(toCell);
                if(distToCell < minDistToCell){
                    minDistToCell = distToCell;
                    closestCell = cell;
                    toClosestCell = toCell;
                }
            }
        }
    }
    //second pass to find the distance to the closest edge
    half minEdgeDistance = 10;
    [unroll]
    for(int x2=-1; x2<=1; x2++){
        [unroll]
        for(int y2=-1; y2<=1; y2++){
            [unroll]
            for(int z2=-1; z2<=1; z2++){
                half3 cell = baseCell + half3(x2, y2, z2);
                half3 cellPosition = cell + rand3dTo3d(cell);
                half3 toCell = cellPosition - value;

                half3 diffToClosestCell = abs(closestCell - cell);
                bool isClosestCell = diffToClosestCell.x + diffToClosestCell.y + diffToClosestCell.z < 0.1;
                if(!isClosestCell){
                    half3 toCenter = (toClosestCell + toCell) * 0.5;
                    half3 cellDifference = normalize(toCell - toClosestCell);
                    half edgeDistance = dot(toCenter, cellDifference);
                    minEdgeDistance = min(minEdgeDistance, edgeDistance);
                }
            }
        }
    }

    half random = rand3dTo1d(closestCell);
    return half3(minDistToCell, random, minEdgeDistance);
}                          
                            </code>
                        </pre>
                        <p>
                            The only thing you need to worry about is the value you plug into it, we used the world position and divided it by 
                            an inspector parameter to easily control how big the voronoi effect looked and then we added the Time to add variation. 
                            The effect now works but if you use it as is, we noticed everything being a bit white (the voronoi ramps linearly) so 
                            we just used a pow function to only use the higher values:
                        </p>
                        <pre>
                            <code>
half3 value = (IN.worldPos.xyz + _WaveA.w+ _WaveB.w + _WaveC.w) / _CellSize;
value.y += _Time.y * _TimeScale;
half3 noise = saturate(pow(voronoiNoise(value),2)-0.3f);
                            </code>
                        </pre>
                        <p>
                            We then modify our color to account for the voronoi:
                        </p>
                        <pre>
                            <code>
half3 color = (noise.x * saturate(1-((depth-IN.screenPos.w)/_FoamThreshold))) + _Color;
                            </code>
                        </pre>
                        <p>
                            And as a last touch we make it so that the water is a slightly less deep blue (_UnderwaterFog) for where the voronoi appears by adding a second
                            falloff to the color:
                        </p>
                        <pre>
                            <code>
float secondFalloff = saturate(dot(lerp(saturate(1-((depth-IN.screenPos.w)/_FoamThreshold)),0,0.1),color)) ;
o.Albedo+= secondFalloff * _UnderwaterFog;

                            </code>
                        </pre>
                        <p>
                            And this is our final water! The code is slightly messy expecially at the end with that secondFalloff variable 
                            but it does the job at showcasing our shader.
                        </p>
                </div>
            </div>
        </div>
    </section>
    <!-- Footer -->
    <footer id="footer">
        <div class="container">
            <ul class="icons">
                <li><a href="https://twitter.com/JamesInvi" class="icon fa-twitter"><span
                            class="label">Twitter</span></a></li>
                <li><a href="https://www.facebook.com/james.karran" class="icon fa-facebook"><span
                            class="label">Facebook</span></a></li>
                <li><a href="mailto:james.invi@gmail.com" class="icon fa-envelope-o"><span
                            class="label">Email</span></a></li>
            </ul>
        </div>
        <div class="copyright">
            &copy; Untitled. All rights reserved.
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../assets/js/jquery.min.js"></script>
    <script src="../assets/js/jquery.scrollex.min.js"></script>
    <script src="../assets/js/skel.min.js"></script>
    <script src="../assets/js/util.js"></script>
    <script src="../assets/js/main.js"></script>

</body>

</html>